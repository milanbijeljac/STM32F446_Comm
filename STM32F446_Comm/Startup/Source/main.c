/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/* **************************************************
 *			    	INCLUDES					    *
 *************************************************  */
#include <stdint.h>
#include <limits.h>
#include <FreeRTOSConfig.h>
#include <stm32f4xx.h>
#include <FreeRTOS.h>
#include <task.h>
#include <timers.h>
#include "types.h"
#include "sys_clock.h"
#include "stm32f446_gpio_driver.h"
#include "stm32f446_can_driver.h"
#include "uart_driver.h"
#include "Messages_Cfg.h"

/* **************************************************
 *					DEFINES 					    *
 *************************************************  */


/* **************************************************
 *			    FUNCTION PROTOTYPES					*
 *************************************************  */
/**
 *
 * \brief      - Function used for GPIO initialization (CAN and UART)
 * \param[in]  - NONE
 * \return     - NONE
 * \globals    - NONE
 *
 */
static void GPIO_Config(void);

/**
 *
 * \brief      - Function used for timers initialization which are used for sending of CAN messages
 * \param[in]  - NONE
 * \return     - NONE
 * \globals    - uint32 countFail - used to track failed initializations of counters
 *
 */
static uint8 CAN_v_InitTimers(void);

/**
 *
 * \brief      - Callback function - triggered when timer expires
 * \param[in]  - TimerHandle_t xCanTImer
 * \return     - NONE
 * \globals    - askHandle_t canTxTaskHandle - handle of CAN TX task
 *
 */
static void vCanTxTimerCallback (TimerHandle_t xCanTImer);

/* **************************************************
 *			    GLOBAL VARIABLES 					*
 *************************************************  */

/** Counters used to track how many times CAN_RX and CAN_TX tasks executed */
volatile uint32 u_counterTask1 = 0, u_counterTask2 = 0;

/** Counter that is used to track failed initializations of timers */
uint8 countFail = 0u;

TimerHandle_t xTimersCan[NUMBER_OF_MESSAGES];
TaskHandle_t canTxTaskHandle;

extern Message_Cfg_t MessageCfg[5];
/* TODO: Clean -  Test variables */
uint32 counterFull, counterOverrun;

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/****************************************************/

static void GPIO_Config(void)
{
	/* CAN GPIO initialization */
	GPIO_v_PeripheralClockControl(GPIOB, ENABLE);

	GPIO_PinConfig_t GPIO_PinConfiguration;

	GPIO_PinConfiguration.GPIO_PinNumber = 8u;
	GPIO_PinConfiguration.GPIO_PinMode = ALTERNATE_FUNCTION_MODE;
	GPIO_PinConfiguration.GPIO_PinAltFunMode = AF9;

	GPIO_v_Init(GPIOB, GPIO_PinConfiguration);

	GPIOx_v_GPIOCfgStructClear(&GPIO_PinConfiguration);

	GPIO_PinConfiguration.GPIO_PinNumber = 9u;
	GPIO_PinConfiguration.GPIO_PinMode = ALTERNATE_FUNCTION_MODE;
	GPIO_PinConfiguration.GPIO_PinAltFunMode = AF9;

	GPIO_v_Init(GPIOB, GPIO_PinConfiguration);

	/* UART GPIO initialization */
	GPIO_v_PeripheralClockControl(GPIOA, ENABLE);
	//GPIOx_v_GPIOCfgStructClear(&GPIO_PinConfiguration);

	//GPIO_PinConfiguration.GPIO_PinNumber = 2u;
	//GPIO_PinConfiguration.GPIO_PinMode = ALTERNATE_FUNCTION_MODE;
	//GPIO_PinConfiguration.GPIO_PinAltFunMode = AF7;

	//GPIO_v_Init(GPIOB, GPIO_PinConfiguration);

	//GPIOx_v_GPIOCfgStructClear(&GPIO_PinConfiguration);

	//GPIO_PinConfiguration.GPIO_PinNumber = 3u;
	//GPIO_PinConfiguration.GPIO_PinMode = ALTERNATE_FUNCTION_MODE;
	//GPIO_PinConfiguration.GPIO_PinAltFunMode = AF7;

	//GPIO_v_Init(GPIOB, GPIO_PinConfiguration);

    /* For some reason code above is not working, need to debug */
   GPIOA->MODER &= ~((3 << (2 * 2)) | (3 << (3 * 2)));
   GPIOA->MODER |=  (2 << (2 * 2)) | (2 << (3 * 2));

   GPIOA->AFR[0] &= ~((0xF << (4 * 2)) | (0xF << (4 * 3)));
   GPIOA->AFR[0] |=  (7 << (4 * 2)) | (7 << (4 * 3));
}

void vCanTxTimerCallback(TimerHandle_t xTimer)
{
    uint32 msgIndex = (uint32)pvTimerGetTimerID(xTimer);

    /* Notify CAN TX task that timer expired, set corresponding bits to 1 */
    /* configTASK_NOTIFICATION_ARRAY_ENTRIES is not configured (is 1, so there is no uint32 arr[x]), and we have one 32 bit value for 32 different evens for every task */
    xTaskNotify(canTxTaskHandle, (1U << msgIndex), eSetBits);
}
static uint8 CAN_v_InitTimers(void)
{
	uint8  i;

	/* Initialization of timers. For more information check FreeRTOS documentation */
	for(i = 0; i < NUMBER_OF_MESSAGES; i++)
	{
		xTimersCan[i] = xTimerCreate("CAN message timer", pdMS_TO_TICKS(MessageCfg[i].time), pdTRUE, (void*)i, vCanTxTimerCallback);
		if(xTimersCan[i] == NULL)
		{
			countFail++;
			return 1;
		}
		else
		{
			if(xTimerStart(xTimersCan[i], 0) != pdPASS)
			{
				countFail++;
				return 1;
			}
		}
	}
	return 0;
}

void vTaskIdle(void *pvParameters)
{
    while (1)
    {

        vTaskDelay(pdMS_TO_TICKS(500));
    }

    vTaskDelete(NULL);
}

void vTaskUartRx(void *pvParameters)
{
    while (1)
    {
        vTaskDelay(pdMS_TO_TICKS(500));
    }

    vTaskDelete(NULL);
}

void vTaskUartTx(void *pvParameters)
{
    while (1)
    {
    	UART_Write_Message("First message in cycle cycle cycle ...\n", 200);
        vTaskDelay(pdMS_TO_TICKS(1000));
    }

    vTaskDelete(NULL);
}

void vTaskComRx(void *pvParameters)
{
	/* TODO: Clean - test Variables */
	uint8 num1, num2;
    while (1)
    {
    	num1 = (uint8)CAN1->RF0R & 0x8;
    	num2 = (uint8)CAN1->RF0R & 16;
    	u_counterTask2 ++;
    	counterFull += num1;
    	counterOverrun += num2;

    	vTaskDelay(pdMS_TO_TICKS(5));
    }

    vTaskDelete(NULL);
}

void vTaskComTx(void *pvParameters)
{
	uint8 retVal, i;
	uint32 u_notifiedValue;
	retVal = CAN_v_InitTimers();

	if(retVal != 0)
	{
		/* TODO: Perform reset, start initialization again */
	}
    while (1)
    {
    	u_counterTask1++;

    	xTaskNotifyWait(0, ULONG_MAX, &u_notifiedValue, portMAX_DELAY);
    	/* Check for events and send corresponding messages */
    	for(i = 0; i < NUMBER_OF_MESSAGES; i++)
    	{
    		if(u_notifiedValue & (1u << i))
    		{
    			CAN_v_TransmitMessage(CAN1, &MessageCfg[i].CanTxHandle);
    		}
    	}
    }

    vTaskDelete(NULL);
}


int main(void)
{
	(void)Sys_v_FrequencyConfig(128u, 4u);
	GPIO_Config();
	CAN_v_Init(CAN1);
	CAN_v_FiltersInit(CAN1);
	UART_v_Init(SystemCoreClock, 115200);
	xTaskCreate(vTaskComTx , "Com Tx task"   , 128, NULL, configMAX_PRIORITIES - 1, &canTxTaskHandle);
	xTaskCreate(vTaskComRx , "Com Rx task"   , 128, NULL, configMAX_PRIORITIES - 1, NULL);
	xTaskCreate(vTaskUartTx, "UART Tx task " , 128, NULL, configMAX_PRIORITIES - 2, NULL);
	xTaskCreate(vTaskUartRx, "UART Rx task " , 128, NULL, tskIDLE_PRIORITY + 1, NULL); /* Will be used only for configuration purposes where other tasks will be suspended */
	xTaskCreate(vTaskIdle  , "Idle task "    , 128, NULL, tskIDLE_PRIORITY, NULL);
	vTaskStartScheduler();
    /* Loop forever */
	for(;;);
}
